package jeops.parser;

/* Generated By:JavaCC: Do not edit this line. Parser.java */
import java.util.*;
import jeops.engine.*;
import jeops.expressions.*;

public class Parser implements ParserConstants {

	private boolean debug = false;

  private static Vector regra_motor;
  private static int index_regra = 0;

//  private static Vector expr_params;
  private static Hashtable local_dec; //Lista de declaracoes locais(rapido)

//--------------- VALORES DE RETORNO -------------------
  private static Declaracoes ht; //Lista de Declaracoes
  private static Hashtable ht2; //Lista de Declaracoes locais do
							// campo de acao. Por csff em 02.04.98
  private static Declaracoes local_decs; //Lista de declaracoes locais
  private static Vector local_Actions; //Usado para as acoes locais
  private static Vector expr_prec;  // Express�es da precondi��o  Por csff em 30/01
  private static Vector expr_metodos; // Metodos encadeados      Por csff em 28/03
  private static Vector all_Actions; //Usado no NT ActionList()
  public ParserTokenManager token_source;
  ASCII_UCodeESC_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[24];
  final private int[] jj_la1_0 = {0x4000,0x80000,0x0,0x200000,0x1e04a000,0x204a000,0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x0,0x0,0xe0000000,0x0,0x0,0x4a000,0xe0000000,0x0,0x0,0x42000,};
  final private int[] jj_la1_1 = {0x0,0x0,0x200000,0x0,0x2108808,0x2108808,0x8000,0x400,0x8000000,0x400,0x0,0x8000000,0x8000,0x8000000,0x3f6,0x3f6,0x1,0x6,0x200000,0x2108800,0x1,0x6,0x3f0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  static final class JJCalls {
	int gen;
	Token first;
	int arg;
	JJCalls next;
  }

  public Parser(java.io.InputStream stream) {
	jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
	token_source = new ParserTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public Parser(java.io.Reader stream) {
	jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
	token_source = new ParserTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
//------------------------------------------------------

  public Parser(String arq, RuleBase br) throws ParseException,
					java.io.FileNotFoundException {
	Parser parser;
	//parametros
//    expr_params = new Vector(0);
	//Objetos do parser
/* Era (em 03/03/99)
	regra_motor = new Regra[NUM_REGRAS];
 e virou: */
	regra_motor = new Vector();

	ht = new Declaracoes();
	ht2 = new Hashtable();  // Por csff em 02.04.98
	local_decs = new Declaracoes(); //duas colunas
	local_dec = new Hashtable();
	local_Actions = new Vector();
	expr_prec = new Vector();      // Por csff em 30/01
	all_Actions = new Vector(0);
	index_regra = 0;
	parser = new Parser(new java.io.FileInputStream(arq));
	parser.CompilationUnit();
	for (int yy = 0; yy < index_regra; yy++)
		br.addRule((Rule)regra_motor.elementAt(yy));
  }        
  public Parser(ParserTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  final public void ActionList() throws ParseException {
  Token tid1 = null, tid2 = null;
  JavaExpr[] parametros = null;
  JavaExpr localExpr = null;    // Por csff em 05.02.98
  ActionJavaExpr expr_action;
  String nome, tipo;
  boolean flagMaisDeUmaDeclaracao;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case INSERT:
	  jj_consume_token(INSERT);
	  jj_consume_token(57);
	  localExpr = PreList();
	  jj_consume_token(58);
	  jj_consume_token(54);
	expr_action = new ActionJavaExpr(ActionJavaExpr.CREATE, localExpr);
	all_Actions.addElement(expr_action);
	  break;
	case DELETE:
	  jj_consume_token(DELETE);
	  jj_consume_token(57);
	  localExpr = PreList();
	  jj_consume_token(58);
	  jj_consume_token(54);
	expr_action = new ActionJavaExpr(ActionJavaExpr.DELETE, localExpr);
	all_Actions.addElement(expr_action);
	  break;
	case MODIFIED:
	  jj_consume_token(MODIFIED);
	  jj_consume_token(57);
	  localExpr = PreList();
	  jj_consume_token(58);
	  jj_consume_token(54);
	expr_action = new ActionJavaExpr(ActionJavaExpr.MODIFY, localExpr);
	all_Actions.addElement(expr_action);
	  break;
	default:
	  jj_la1[10] = jj_gen;
	  if (jj_2_1(2)) {
		/* Totalmente por csff em 31.03.98 */
		  tid1 = jj_consume_token(IDENTIFIER);
		jj_consume_token(ATRIBUICAO);
		localExpr = PreList();
		jj_consume_token(54);
	expr_action = new ActionJavaExpr (ActionJavaExpr.ASSIGN, tid1.image, localExpr);
	all_Actions.addElement(expr_action);
	  } else if (jj_2_2(4)) {
		localExpr = PreList();
		jj_consume_token(54);
	expr_action = new ActionJavaExpr(ActionJavaExpr.METHOD, localExpr);
	all_Actions.addElement(expr_action);
	  } else if (jj_2_3(3)) {
		tipo = Name();
		tid2 = jj_consume_token(IDENTIFIER);
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case ATRIBUICAO:
		  jj_consume_token(ATRIBUICAO);
		  localExpr = PreList();
		  break;
		default:
		  jj_la1[7] = jj_gen;
		  ;
		}
flagMaisDeUmaDeclaracao = false;
	  ht2.put(tid2.image, tipo);
	  expr_action = new ActionJavaExpr (ActionJavaExpr.DECLAR, tipo, tid2.image, localExpr);
	  all_Actions.addElement(expr_action);
		label_6:
		while (true) {
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case 59:
			;
			break;
		  default:
			jj_la1[8] = jj_gen;
			break label_6;
		  }
		  jj_consume_token(59);
		  tid2 = jj_consume_token(IDENTIFIER);
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case ATRIBUICAO:
			jj_consume_token(ATRIBUICAO);
			localExpr = PreList();
			break;
		  default:
			jj_la1[9] = jj_gen;
			;
		  }
flagMaisDeUmaDeclaracao = true;
	  ht2.put(tid2.image, tipo);
	  expr_action = new ActionJavaExpr (ActionJavaExpr.DECLAR, tipo, tid2.image, localExpr);
	  all_Actions.addElement(expr_action);
		}
		jj_consume_token(54);

	  } else {
		jj_consume_token(-1);
		throw new ParseException();
	  }
	}
  }    
  final public JavaExpr Arit_Expression() throws ParseException {
  String operador = null;
  JavaExpr expresq = null, exprdir = null, result = null;
	expresq = Bool_Expression();
	label_12:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case PLUS:
	  case MINUS:
	  case MULTIPLY:
	  case DIVIDE:
		;
		break;
	  default:
		jj_la1[16] = jj_gen;
		break label_12;
	  }
	  operador = AritOperators();
	  exprdir = Bool_Expression();
	}
	if (exprdir != null)  {
	  switch(operador.charAt(0)) {
		case '+' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.SUM );
				   break;
		case '-' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.SUB );
				   break;
		case '*' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.MUL );
				   break;
		case '/' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.DIV );
				   break;
		default  : {if (true) return expresq;}
	  }
	  {if (true) return result;}
	}
	else
	  {if (true) return expresq;}
	throw new Error("Missing return statement in function");
  }  
  final public String AritOperators() throws ParseException {
  Token t = null;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case PLUS:
	  t = jj_consume_token(PLUS);
	{if (true) return t.image;}
	  break;
	case MINUS:
	  t = jj_consume_token(MINUS);
	{if (true) return t.image;}
	  break;
	case DIVIDE:
	  t = jj_consume_token(DIVIDE);
	{if (true) return t.image;}
	  break;
	case MULTIPLY:
	  t = jj_consume_token(MULTIPLY);
	{if (true) return t.image;}
	  break;
	default:
	  jj_la1[20] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }  
  final public JavaExpr Bool_Expression() throws ParseException {
  String operador = null;
  JavaExpr expresq = null, exprdir = null, result = null;
	//Era Primary_Expression()
	  expresq = Primary_Expression();
	label_13:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case AND:
	  case OR:
		;
		break;
	  default:
		jj_la1[17] = jj_gen;
		break label_13;
	  }
	  operador = BoolBOperators();
	  if (debug) System.out.println("Bool: "+operador);
	  exprdir = Expression();
	}
	if (exprdir != null)  {
	  switch(operador.charAt(0)) {
		case '&' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.LAND );
				   break;
		case '|' : result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.LOR );
				   break;
		default  : {if (true) return expresq;}
	  }
	  {if (true) return result;}
	}
	else
	  {if (true) return expresq;}
	throw new Error("Missing return statement in function");
  }  
  final public String BoolBOperators() throws ParseException {
  Token t = null;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case AND:
	  t = jj_consume_token(AND);
	{if (true) return t.image;}
	  break;
	case OR:
	  t = jj_consume_token(OR);
	{if (true) return t.image;}
	  break;
	default:
	  jj_la1[21] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }  
  final public String Boolean() throws ParseException {
  Token t = null;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case TRUE:
	  t = jj_consume_token(TRUE);
	{if (true) return t.image;}
	  break;
	case FALSE:
	  t = jj_consume_token(FALSE);
	{if (true) return t.image;}
	  break;
	default:
	  jj_la1[23] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }  
  final public void BoolUOperators() throws ParseException {
	jj_consume_token(NOT);
  }  
/*****************************************
 * A GRAMATICA COMECA AQUI               *
 *****************************************/

/*
 * Estrutura da sintaxe do programa.
 */
  final public void CompilationUnit() throws ParseException {
	label_1:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case IMPORT:
		;
		break;
	  default:
		jj_la1[0] = jj_gen;
		break label_1;
	  }
	  ImportDeclaration();
	}
	label_2:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case RULE:
		;
		break;
	  default:
		jj_la1[1] = jj_gen;
		break label_2;
	  }
	  RuleDeclaration();
	}
	jj_consume_token(0);
  }  
  final public void disable_tracing() {
  }  
  final public void enable_tracing() {
  }  
  final public JavaExpr Expression() throws ParseException {
  JavaExpr expr = null, expresq = null, exprdir = null, result = null;
  String operador = null;
  String nomeClasse = null;  // Por csff em 05.02.98
  JavaExpr[] params = null;
	if (jj_2_7(5)) {
	  BoolUOperators();
	  expr = Expression();
	result = new UnaryJavaExpr( expr, UnaryJavaExpr.LNOT );
	{if (true) return result;}
	} else if (jj_2_8(5)) {
	  jj_consume_token(NEW);
	  nomeClasse = Name();
	  params = ParametersList();
	try {
		result = new ConstructorJavaExpr(nomeClasse, params);
	} catch (Exception e) {
		System.out.println("Erro: ObjectConstructorNode.");
		e.printStackTrace();
		System.exit(0);
	}
	{if (true) return result;}
	} else if (jj_2_9(5)) {
	  expresq = Arit_Expression();
	  label_11:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case AND:
		case OR:
		case GREATER:
		case LESS:
		case EQUAL:
		case LE:
		case GE:
		case DIF:
		  ;
		  break;
		default:
		  jj_la1[14] = jj_gen;
		  break label_11;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case GREATER:
		case LESS:
		case EQUAL:
		case LE:
		case GE:
		case DIF:
		  operador = RelOperators();
		  break;
		case AND:
		case OR:
		  operador = BoolBOperators();
		  break;
		default:
		  jj_la1[15] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
		exprdir = Expression();
	  }
	if (operador != null) {
	   if (operador.equals(">"))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.GT );
	   else if (operador.equals("<"))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.LT );
	   else if (operador.equals(">="))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.GEQ );
	   else if (operador.equals("<="))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.LEQ );
	   else if (operador.equals("=="))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.EQ );
	   else if (operador.equals("!="))
		  result = new BinaryJavaExpr(expresq, exprdir, BinaryJavaExpr.NEQ );
	   else if (operador.equals("&&"))
		  result = new BinaryJavaExpr( expresq, exprdir, BinaryJavaExpr.LAND );
	   else if (operador.equals("||"))
		  result = new BinaryJavaExpr( expresq, exprdir, BinaryJavaExpr.LOR );
	   else
		  {if (true) return expresq;}
	   {if (true) return result;}
	}
	else
	   {if (true) return expresq;}
	} else {
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }    
  final public ParseException generateParseException() {
	jj_expentries.removeAllElements();
	boolean[] la1tokens = new boolean[60];
	for (int i = 0; i < 60; i++) {
	  la1tokens[i] = false;
	}
	if (jj_kind >= 0) {
	  la1tokens[jj_kind] = true;
	  jj_kind = -1;
	}
	for (int i = 0; i < 24; i++) {
	  if (jj_la1[i] == jj_gen) {
		for (int j = 0; j < 32; j++) {
		  if ((jj_la1_0[i] & (1<<j)) != 0) {
			la1tokens[j] = true;
		  }
		  if ((jj_la1_1[i] & (1<<j)) != 0) {
			la1tokens[32+j] = true;
		  }
		}
	  }
	}
	for (int i = 0; i < 60; i++) {
	  if (la1tokens[i]) {
		jj_expentry = new int[1];
		jj_expentry[0] = i;
		jj_expentries.addElement(jj_expentry);
	  }
	}
	jj_endpos = 0;
	jj_rescan_token();
	jj_add_error_token(0, 0);
	int[][] exptokseq = new int[jj_expentries.size()][];
	for (int i = 0; i < jj_expentries.size(); i++) {
	  exptokseq[i] = (int[])jj_expentries.elementAt(i);
	}
	return new ParseException(token, exptokseq, tokenImage);
  }  
  private static JavaExpr[] getArray( Vector v ) {
	 JavaExpr[] temp = new JavaExpr[v.size()];
	 for ( int i=0; i < v.size(); i++ ) {
		temp[i] = (JavaExpr) v.elementAt(i);
	 }
	 return temp;
  }  
  final public Token getNextToken() {
	if (token.next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	jj_gen++;
	return token;
  }  
  final public Token getToken(int index) {
	Token t = lookingAhead ? jj_scanpos : token;
	for (int i = 0; i < index; i++) {
	  if (t.next != null) t = t.next;
	  else t = t.next = token_source.getNextToken();
	}
	return t;
  }  
  final public void ImportDeclaration() throws ParseException {
	jj_consume_token(IMPORT);
	Name();
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case 53:
	  jj_consume_token(53);
	  jj_consume_token(MULTIPLY);
	  break;
	default:
	  jj_la1[2] = jj_gen;
	  ;
	}
	jj_consume_token(54);
  }  
  final private boolean jj_2_1(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_1();
	jj_save(0, xla);
	return retval;
  }  
  final private boolean jj_2_2(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_2();
	jj_save(1, xla);
	return retval;
  }  
  final private boolean jj_2_3(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_3();
	jj_save(2, xla);
	return retval;
  }  
  final private boolean jj_2_4(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_4();
	jj_save(3, xla);
	return retval;
  }  
  final private boolean jj_2_5(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_5();
	jj_save(4, xla);
	return retval;
  }  
  final private boolean jj_2_6(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_6();
	jj_save(5, xla);
	return retval;
  }  
  final private boolean jj_2_7(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_7();
	jj_save(6, xla);
	return retval;
  }  
  final private boolean jj_2_8(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_8();
	jj_save(7, xla);
	return retval;
  }  
  final private boolean jj_2_9(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_9();
	jj_save(8, xla);
	return retval;
  }  
  final private boolean jj_3_1() {
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(ATRIBUICAO)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_2() {
	if (jj_3R_15()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(54)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_3() {
	if (jj_3R_16()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_17()) jj_scanpos = xsp;
	else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_18()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	if (jj_scan_token(54)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_4() {
	if (jj_scan_token(57)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(58)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_5() {
	if (jj_scan_token(57)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_28()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	if (jj_scan_token(58)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_6() {
	if (jj_scan_token(53)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_7() {
	if (jj_3R_20()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_8() {
	if (jj_scan_token(NEW)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_16()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_21()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_9() {
	if (jj_3R_22()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_23()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_15() {
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_16() {
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3_6()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_17() {
	if (jj_scan_token(ATRIBUICAO)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_18() {
	if (jj_scan_token(59)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_19() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3_7()) {
	jj_scanpos = xsp;
	if (jj_3_8()) {
	jj_scanpos = xsp;
	if (jj_3_9()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_20() {
	if (jj_scan_token(NOT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_21() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3_4()) {
	jj_scanpos = xsp;
	if (jj_3_5()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_22() {
	if (jj_3R_24()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_25()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_23() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_26()) {
	jj_scanpos = xsp;
	if (jj_3R_27()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_24() {
	if (jj_3R_29()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_30()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_25() {
	if (jj_3R_31()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_24()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_26() {
	if (jj_3R_32()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_27() {
	if (jj_3R_33()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_28() {
	if (jj_scan_token(59)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_29() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_34()) {
	jj_scanpos = xsp;
	if (jj_3R_35()) {
	jj_scanpos = xsp;
	if (jj_3R_36()) {
	jj_scanpos = xsp;
	if (jj_3R_37()) {
	jj_scanpos = xsp;
	if (jj_3R_38()) {
	jj_scanpos = xsp;
	if (jj_3R_39()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_30() {
	if (jj_3R_33()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_31() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_40()) {
	jj_scanpos = xsp;
	if (jj_3R_41()) {
	jj_scanpos = xsp;
	if (jj_3R_42()) {
	jj_scanpos = xsp;
	if (jj_3R_43()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_32() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_44()) {
	jj_scanpos = xsp;
	if (jj_3R_45()) {
	jj_scanpos = xsp;
	if (jj_3R_46()) {
	jj_scanpos = xsp;
	if (jj_3R_47()) {
	jj_scanpos = xsp;
	if (jj_3R_48()) {
	jj_scanpos = xsp;
	if (jj_3R_49()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_33() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_50()) {
	jj_scanpos = xsp;
	if (jj_3R_51()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_34() {
	if (jj_scan_token(CONST)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_35() {
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_52()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_36() {
	if (jj_scan_token(NULL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_37() {
	if (jj_scan_token(STRING)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_38() {
	if (jj_3R_53()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_39() {
	if (jj_scan_token(57)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_19()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(58)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_40() {
	if (jj_scan_token(PLUS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_41() {
	if (jj_scan_token(MINUS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_42() {
	if (jj_scan_token(DIVIDE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_43() {
	if (jj_scan_token(MULTIPLY)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_44() {
	if (jj_scan_token(GREATER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_45() {
	if (jj_scan_token(LESS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_46() {
	if (jj_scan_token(EQUAL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_47() {
	if (jj_scan_token(GE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_48() {
	if (jj_scan_token(LE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_49() {
	if (jj_scan_token(DIF)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_50() {
	if (jj_scan_token(AND)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_51() {
	if (jj_scan_token(OR)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_52() {
	if (jj_scan_token(53)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_21()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_53() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_54()) {
	jj_scanpos = xsp;
	if (jj_3R_55()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_54() {
	if (jj_scan_token(TRUE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_55() {
	if (jj_scan_token(FALSE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  private void jj_add_error_token(int kind, int pos) {
	if (pos >= 100) return;
	if (pos == jj_endpos + 1) {
	  jj_lasttokens[jj_endpos++] = kind;
	} else if (jj_endpos != 0) {
	  jj_expentry = new int[jj_endpos];
	  for (int i = 0; i < jj_endpos; i++) {
		jj_expentry[i] = jj_lasttokens[i];
	  }
	  boolean exists = false;
	  for (java.util.Enumeration enume = jj_expentries.elements(); enume.hasMoreElements();) {
		int[] oldentry = (int[])(enume.nextElement());
		if (oldentry.length == jj_expentry.length) {
		  exists = true;
		  for (int i = 0; i < jj_expentry.length; i++) {
			if (oldentry[i] != jj_expentry[i]) {
			  exists = false;
			  break;
			}
		  }
		  if (exists) break;
		}
	  }
	  if (!exists) jj_expentries.addElement(jj_expentry);
	  if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	}
  }  
  final private Token jj_consume_token(int kind) throws ParseException {
	Token oldToken;
	if ((oldToken = token).next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	if (token.kind == kind) {
	  jj_gen++;
	  if (++jj_gc > 100) {
		jj_gc = 0;
		for (int i = 0; i < jj_2_rtns.length; i++) {
		  JJCalls c = jj_2_rtns[i];
		  while (c != null) {
			if (c.gen < jj_gen) c.first = null;
			c = c.next;
		  }
		}
	  }
	  return token;
	}
	token = oldToken;
	jj_kind = kind;
	throw generateParseException();
  }  
  final private int jj_ntk() {
	if ((jj_nt=token.next) == null)
	  return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	else
	  return (jj_ntk = jj_nt.kind);
  }  
  final private void jj_rescan_token() {
	jj_rescan = true;
	for (int i = 0; i < 9; i++) {
	  JJCalls p = jj_2_rtns[i];
	  do {
		if (p.gen > jj_gen) {
		  jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
		  switch (i) {
			case 0: jj_3_1(); break;
			case 1: jj_3_2(); break;
			case 2: jj_3_3(); break;
			case 3: jj_3_4(); break;
			case 4: jj_3_5(); break;
			case 5: jj_3_6(); break;
			case 6: jj_3_7(); break;
			case 7: jj_3_8(); break;
			case 8: jj_3_9(); break;
		  }
		}
		p = p.next;
	  } while (p != null);
	}
	jj_rescan = false;
  }  
  final private void jj_save(int index, int xla) {
	JJCalls p = jj_2_rtns[index];
	while (p.gen > jj_gen) {
	  if (p.next == null) { p = p.next = new JJCalls(); break; }
	  p = p.next;
	}
	p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }  
  final private boolean jj_scan_token(int kind) {
	if (jj_scanpos == jj_lastpos) {
	  jj_la--;
	  if (jj_scanpos.next == null) {
		jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	  } else {
		jj_lastpos = jj_scanpos = jj_scanpos.next;
	  }
	} else {
	  jj_scanpos = jj_scanpos.next;
	}
	if (jj_rescan) {
	  int i = 0; Token tok = token;
	  while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	  if (tok != null) jj_add_error_token(kind, i);
	}
	return (jj_scanpos.kind != kind);
  }  
									 // Por csff em 30/01

/**
   Lista de declaracoes locais com sua respectivas acoes.
*/
  final public void LocalDeclarations() throws ParseException {
  String tipo; Token s = null; JavaExpr local_expr = null;
  int index = 0;
  //Inicializa novamente
  local_dec = new Hashtable();
	label_5:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case IDENTIFIER:
		;
		break;
	  default:
		jj_la1[6] = jj_gen;
		break label_5;
	  }
	  tipo = Name();
	  s = jj_consume_token(IDENTIFIER);
	  jj_consume_token(ATRIBUICAO);
	  local_expr = PreList();
	local_decs.put(s.image, tipo);
	index++;
	local_dec.put(s.image, tipo); //Usado para procurar o tipo dos Ids.
	local_Actions.addElement(local_expr);
	  jj_consume_token(54);
	}
  }  
  public static void main(String args[]) {
	Parser parser;

		RuleBase br = new RuleBase(new ObjectBase());
	try {
	  new Parser(args[0], br);
	} catch (Exception e) {
	  System.out.println("Erro: " + e);
	  e.printStackTrace();
	  System.exit(1);
	}
	br.dump();
  }      
  final public String Name() throws ParseException {
  Token t = null, s = null; String str = "";
	t = jj_consume_token(IDENTIFIER);
	label_8:
	while (true) {
	  if (jj_2_6(2)) {
		;
	  } else {
		break label_8;
	  }
	  jj_consume_token(53);
	  s = jj_consume_token(IDENTIFIER);
										str = str+"."+s.image;
	}
	if (s == null) {
	  {if (true) return t.image;}
	}
	else {
	  {if (true) return t.image+str;}
	}
	throw new Error("Missing return statement in function");
  }  
  final public JavaExpr[] ParametersList() throws ParseException {
  Vector expr_params = new Vector(0);
  String operador = null;
  Token tconst, tid1 = null, tid2 = null;
  JavaExpr[] parametros = null;
  JavaExpr expressao = null;
	if (jj_2_4(2)) {
	  jj_consume_token(57);
	  jj_consume_token(58);
	{if (true) return getArray(expr_params);}
	} else if (jj_2_5(2)) {
	  jj_consume_token(57);
	  expressao = Expression();
	expr_params.addElement(expressao);
	if (index_regra == 2) { //terceira regra
	   if (debug) System.out.println("Imprimindo a Hashtable alterada:=====>");
	   if (debug) System.out.println(expr_params.toString());
	   if (debug) System.out.println("Fim da Hashtable alterada=====>");
	}
	  label_7:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case 59:
		  ;
		  break;
		default:
		  jj_la1[11] = jj_gen;
		  break label_7;
		}
		jj_consume_token(59);
		expressao = Expression();
	expr_params.addElement(expressao);
	  }
	  jj_consume_token(58);
	if (debug) System.out.println("----O array completo de objetos eh:----");
	if (debug) System.out.println(expr_params.toString());
	if (debug) System.out.println("----O array completo foi impresso----");
	{if (true) return getArray(expr_params);}
	} else {
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }  
/**
   Lista das pr�-condi��es.
*/
  final public void Preconditions() throws ParseException {
									 // Por csff em 30/01
  JavaExpr local_expr = null;
	label_4:
	while (true) {
	  local_expr = PreList();
									 // Por csff em 30/01
	expr_prec.addElement(local_expr);// Por csff em 30/01

	  jj_consume_token(54);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case FALSE:
	  case NULL:
	  case TRUE:
	  case NEW:
	  case NOT:
	  case CONST:
	  case IDENTIFIER:
	  case STRING:
	  case 57:
		;
		break;
	  default:
		jj_la1[5] = jj_gen;
		break label_4;
	  }
	}
  }    
  final public JavaExpr PreList() throws ParseException {
  JavaExpr expr;
	expr = Expression();
	{if (true) return expr;}
	throw new Error("Missing return statement in function");
  }  
  final public JavaExpr Primary_Expression() throws ParseException {
  JavaExpr expr = null, expr1 = null, metAtual = null;
  JavaExpr[] parametros = null;
  String operador = null;
  Token tconst = null, tid1 = null, tid2 = null;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case CONST:
	  tconst = jj_consume_token(CONST);
	expr = new ConstJavaExpr( Integer.parseInt(tconst.image) );
	{if (true) return expr;}
	  break;
	case IDENTIFIER:
	  // Versoes futuras   // J� � presente - por csff em 28.03.98
	   tid1 = jj_consume_token(IDENTIFIER);
	   // por csff em 28.03.98
	metAtual = null;   // por csff em 28.03.98

	  label_14:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case 53:
		  ;
		  break;
		default:
		  jj_la1[18] = jj_gen;
		  break label_14;
		}
		jj_consume_token(53);
		tid2 = jj_consume_token(IDENTIFIER);
		parametros = ParametersList();
   /* Inicio de por csff em 28.03.98 */
	   String tipo_objeto2;
	   if ((String)ht.get(tid1.image) == null) //Nao pert. as dec. globais
		  tipo_objeto2 = (String)local_dec.get(tid1.image);
/* Por csff em 02.04.98 */
	   else if (ht2 != null &&
					(String)ht2.get(tid1.image) != null)
									   //Pertence as dec. locais da acao
		tipo_objeto2 = (String)ht2.get(tid1.image);
/* Fim de por csff em 02.04.98 */
	   else //Neste caso o obj. foi declarado globalmente
		  tipo_objeto2 = (String)ht.get(tid1.image);

	  if (metAtual == null) {
		  try {
			metAtual = new MethodJavaExpr(tipo_objeto2, tid1.image,
				tid2.image, parametros);
			if (debug) System.out.println("Vou agora imprimir a expr");
			if (debug) metAtual.dump();
			if (debug) System.out.println("Ok. -----");
		  }catch(NoSuchMethodException e) {
			 System.out.println("Metodo inexistente: "+e.getMessage());
			 e.printStackTrace();
			 System.exit(0);
		  }catch(NoSuchClassException e) {
			 System.out.println("Classe inexistente: "+e.getMessage());
			 e.printStackTrace();
			 System.exit(0);
		  }
	  } else {  // Metodos encadeados.
		  try {
			metAtual = new MethodJavaExpr((MethodJavaExpr)metAtual,
				tid2.image, parametros);
			if (debug) System.out.println("Vou agora imprimir a expr");
			if (debug) metAtual.dump();
			if (debug) System.out.println("Ok. -----");
		  }catch(NoSuchMethodException e) {
			 System.out.println("Metodo inexistente: "+e.getMessage());
			 e.printStackTrace();
			 System.exit(0);
		  }
	  }
	  }
	String tipo_objeto;
	if ((String)ht.get(tid1.image) != null) //Pertence as dec. globais
	   tipo_objeto = (String)ht.get(tid1.image);
/* Por csff em 03.04.98 */
	else if (ht2 != null &&
					(String)ht2.get(tid1.image) != null)
									   //Pertence as dec. locais da acao
	   tipo_objeto = (String)ht2.get(tid1.image);
/* Fim de por csff em 03.04.98 */
	else //Neste caso o obj. foi declarado numa decl local das premissas
	   tipo_objeto = (String)local_dec.get(tid1.image);

	if (debug) System.out.println("tid1 = "+tid1.image);
	if (debug) System.out.println("tid1 (Tipo)= "+tipo_objeto);
	if (tid2 != null) {
	   if (debug) System.out.println("tid2 = "+tid2.image);
	} else {
	   if (debug) System.out.println("tid2 = null");
	}
	if (tid2 == null) {
		try {
		  expr = new VarJavaExpr(tipo_objeto,tid1.image);
		}catch(ClassNotFoundException e) {
		  System.out.println("Classe inexistente: "+e.getMessage());
		  e.printStackTrace();
		  System.exit(0);
		}
	}
	else {
	  expr = metAtual;
	} //Fim do else
	{if (true) return expr;}
	  break;
	case NULL:
	  jj_consume_token(NULL);
	expr = new ConstJavaExpr();
	{if (true) return expr;}
	  break;
	case STRING:
	  tconst = jj_consume_token(STRING);
	expr = new ConstJavaExpr(tconst.image.substring(1, tconst.image.length() - 1));
	{if (true) return expr;}
	  break;
	case FALSE:
	case TRUE:
	  operador = Boolean();
	switch(operador.charAt(0)) {
	  case 't' : expr = new ConstJavaExpr(true);
				 break;
	  case 'f' : expr = new ConstJavaExpr(false);
				 break;
	}
	{if (true) return expr;}
	  break;
	case 57:
	  jj_consume_token(57);
	  expr = Expression();
	  jj_consume_token(58);
	 {if (true) return expr;}
	  break;
	default:
	  jj_la1[19] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }      
  public void ReInit(java.io.InputStream stream) {
	jj_input_stream.ReInit(stream, 1, 1);
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public void ReInit(java.io.Reader stream) {
	jj_input_stream.ReInit(stream, 1, 1);
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public void ReInit(ParserTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 24; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  final public String RelOperators() throws ParseException {
  Token t;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case GREATER:
	  t = jj_consume_token(GREATER);
	{if (true) return t.image;}
	  break;
	case LESS:
	  t = jj_consume_token(LESS);
	{if (true) return t.image;}
	  break;
	case EQUAL:
	  t = jj_consume_token(EQUAL);
	{if (true) return t.image;}
	  break;
	case GE:
	  t = jj_consume_token(GE);
	{if (true) return t.image;}
	  break;
	case LE:
	  t = jj_consume_token(LE);
	{if (true) return t.image;}
	  break;
	case DIF:
	  t = jj_consume_token(DIF);
	{if (true) return t.image;}
	  break;
	default:
	  jj_la1[22] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
	throw new Error("Missing return statement in function");
  }  
  final public void RuleBody() throws ParseException {
  all_Actions = new Vector(0);    // Colocado aqui por csff em 17.04.98
  local_Actions = new Vector(0);
	jj_consume_token(DEC);
	ht = TypeList();

	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case LOCAL_DEC:
	  jj_consume_token(LOCAL_DEC);
	  LocalDeclarations();
	if (debug) System.out.println("--> Vai agora imprimir todas as LocalDeclaraions()");
	if (debug) System.out.println("Tamanho do Array: "+local_Actions.size());
	for (int i=0; i < local_Actions.size(); i++) {
	   if (debug) System.out.println("Tipo: "+local_decs.getType(i)+" - Var: "+local_decs.getIdent(i));
	   if (debug) ((JavaExpr) local_Actions.elementAt(i)).dump(1);
	}
	if (debug) System.out.println("--> Fim das LocalDeclarations()");
	  break;
	default:
	  jj_la1[3] = jj_gen;
	  ;
	}
	jj_consume_token(PRE);
	Preconditions();
	if (debug) System.out.println("--> Vai agora imprimir so a PreList()");
	if (debug) for (int c1 = 0; c1 < expr_prec.size(); c1++)    // Por csff em 30/01
	if (debug)    ((JavaExpr)expr_prec.elementAt(c1)).dump();   // Por csff em 30/01
	if (debug) System.out.println("--> Fim da PreList()");
	jj_consume_token(ACT);
	label_3:
	while (true) {
	  ActionList();
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case FALSE:
	  case NULL:
	  case TRUE:
	  case NEW:
	  case INSERT:
	  case DELETE:
	  case MODIFIED:
	  case NOT:
	  case CONST:
	  case IDENTIFIER:
	  case STRING:
	  case 57:
		;
		break;
	  default:
		jj_la1[4] = jj_gen;
		break label_3;
	  }
	}
	if (debug) System.out.println("--> Vai agora imprimir todas as ActionList()");
	if (debug) System.out.println("=Tamanho do Array: "+all_Actions.size());
	if (debug) {
		for (int i=0; i < all_Actions.size(); i++) {
	   		((ActionJavaExpr) all_Actions.elementAt(i)).dump(1);
		}
	}
	if (debug) System.out.println("--> Fim da ActionList()");
  }    
/*
 * Sugue a declaracao da sintaxe.
 */
  final public void RuleDeclaration() throws ParseException {
  Token t;
	jj_consume_token(RULE);
	t = jj_consume_token(IDENTIFIER);
	 regra_motor.addElement(new Rule(t.image, index_regra));
	 expr_prec = new Vector();    // Por csff em 30/01
	 ht = new Declaracoes();  // Por csff em 03.03.99
	 ht2 = new Hashtable();  // Por csff em 03.03.99

	jj_consume_token(55);
	RuleBody();
	jj_consume_token(56);
	 //Insere as declaracoes da regra
	 Enumeration e1, e2;
	 e1 = ht.keys();
	 e2 = ht.elements();
	 while (e1.hasMoreElements())
		 ((Rule)regra_motor.elementAt(index_regra)).addDeclaration(new RuleDeclaration
				   ((String)e2.nextElement(), (String)e1.nextElement()));

	 //Insere as declaracoes locais da regra
	 int index = 0;
	 while (index < local_Actions.size()) {
		 ((Rule)regra_motor.elementAt(index_regra)).addLocalDeclaration(new RuleLocalDeclaration
				   (local_decs.getType(index), local_decs.getIdent(index),
					(JavaExpr)local_Actions.elementAt(index) ));
		 index++;
	 }

	 //Insere as premissas da regra

	 JavaExpr[] precs = getArray(expr_prec);       // Por csff em 30/01
	 for (int t2 = 0; t2 < precs.length; t2++)        // Por csff em 30/01
		((Rule)regra_motor.elementAt(index_regra)).addPrecondition(    // Por csff em 30/01
					new Precondition((JavaExpr)precs[t2]));     // Por csff em 30/01

	 //Insere as acoes da regra
	 for (int i = 0; i < all_Actions.size(); i++)
		 ((Rule)regra_motor.elementAt(index_regra)).addAction(
			  new RuleAction((ActionJavaExpr)all_Actions.elementAt(i)));
	 //Incrementa o indice da regra
	 index_regra++;
	 if (debug) System.out.println("--> Fim da "+index_regra+" Regra.");
  }                
/**
  Retorna uma Hashtable contendo a lista de declaracoes.
*/
  final public Declaracoes TypeList() throws ParseException {
  String tipo; Token s = null; Declaracoes dec = new Declaracoes();
	label_9:
	while (true) {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case IDENTIFIER:
		;
		break;
	  default:
		jj_la1[12] = jj_gen;
		break label_9;
	  }
	  tipo = Name();
	  s = jj_consume_token(IDENTIFIER);
									 dec.put(s.image, tipo);
	  label_10:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case 59:
		  ;
		  break;
		default:
		  jj_la1[13] = jj_gen;
		  break label_10;
		}
		jj_consume_token(59);
		s = jj_consume_token(IDENTIFIER);
							dec.put(s.image, tipo);
	  }
	  jj_consume_token(54);
	}
	{if (true) return dec;}
	throw new Error("Missing return statement in function");
  }  
}